import 'reflect-metadata';
import React from 'react';
import type { Metadata } from 'next';
import './globals.css';
import { initializeDatabase } from '@/infrastructure/shared/databaseInitialization';
import { Provider } from '@/presentation/shared/components/ui/provider';
import { SocialNetworksFooterContainer } from '@/presentation/shared/components/SocialNetworksFooter';
import { container } from '@/infrastructure/container';
import { Logger } from '@/application/shared/Logger';

// Force dynamic rendering to prevent static generation during build
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

async function getWebsiteName(): Promise<string> {
  // Only fetch during runtime, not during build
  if (process.env.NEXT_PHASE === 'phase-production-build') {
    return 'Shower'; // Default during build
  }

  try {
    const baseUrl = process.env.SHOWER_URL || 'http://localhost:3000';

    const response = await fetch(`${baseUrl}/api/settings/name`, {
      cache: 'no-store', // Ensure fresh data
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    return data.name || 'Shower';
  } catch (error) {
    const logger = container.resolve<Logger>('Logger');
    logger.logErrorWithObject(error, 'Failed to fetch website name', { error });
    return 'Shower'; // Default fallback
  }
}

async function getWebsiteIcon(): Promise<string | null> {
  // Only fetch during runtime, not during build
  if (process.env.NEXT_PHASE === 'phase-production-build') {
    return null; // Default during build
  }

  try {
    const baseUrl = process.env.SHOWER_URL || 'http://localhost:3000';

    const response = await fetch(`${baseUrl}/api/settings/icon`, {
      cache: 'no-store', // Ensure fresh data
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    return data.icon?.url || null;
  } catch (error) {
    const logger = container.resolve<Logger>('Logger');
    logger.logErrorWithObject(error, 'Failed to fetch website icon', { error });
    return null; // Default fallback
  }
}

export async function generateMetadata(): Promise<Metadata> {
  const websiteName = await getWebsiteName();
  const websiteIcon = await getWebsiteIcon();

  return {
    title: websiteName,
    description: 'Generated by create next app',
    icons: websiteIcon
      ? {
          icon: websiteIcon,
          shortcut: websiteIcon,
          apple: websiteIcon,
        }
      : undefined,
  };
}

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Initialize database connection - with timeout to prevent hanging
  try {
    await Promise.race([
      initializeDatabase(),
      new Promise((_, reject) =>
        setTimeout(
          () => reject(new Error('Database initialization timeout')),
          5000
        )
      ),
    ]);
  } catch (error) {
    try {
      const logger = container.resolve<Logger>('Logger');
      logger.logErrorWithObject(
        error,
        'Database initialization failed or timed out'
      );
    } catch {
      // Logger not available, continue silently
    }
    // Continue without database to allow the app to start
  }

  return (
    <html suppressHydrationWarning>
      <body>
        <Provider>
          {children}
          <SocialNetworksFooterContainer />
        </Provider>
      </body>
    </html>
  );
}
