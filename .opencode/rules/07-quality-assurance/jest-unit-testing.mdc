---
description: Rules for writing simple, maintainable unit tests focusing on main behaviors without over-mocking or over-testing.
globs: test/unit/**/*.test.ts
alwaysApply: false
---

Sub rule 1: Test Simplicity
- Test only main behaviors and happy paths
- Avoid testing implementation details
- Focus on what the code does, not how it does it
- Keep tests short and readable

Sub rule 2: Test Structure
- Name test files as `ModuleName.test.ts`
- Group related tests using `describe` blocks
- Use descriptive test names that explain the behavior
- Follow Arrange-Act-Assert pattern

Sub rule 3: Minimal Mocking
- Mock only external dependencies (API calls, database, file system)
- Never mock Chakra UI components or React components
- Use real implementations when possible
- Avoid mocking internal application logic

Sub rule 4: Simple Assertions
- Use `toBe` for primitive comparisons
- Use `toEqual` for object/array equality
- Use `toBeTruthy`/`toBeFalsy` for boolean checks
- Keep assertions focused on the expected outcome

Sub rule 5: Test Isolation
- No shared state between tests
- Use `beforeEach` only for essential setup
- Avoid complex setup procedures
- Keep tests independent and fast

Sub rule 6: Testing Logging
- Mock `UnifiedLogger` in tests using jest mocks: `const mockLogger = { logInfo: jest.fn(), logError: jest.fn() }`
- Verify log calls with proper arguments: `expect(mockLogger.logInfo).toHaveBeenCalledWith('Message', { key: 'value' })`
- Test logging behavior without testing implementation details
- Use test-specific log levels to avoid noise in test output
- Avoid asserting on exact log message formats; focus on behavior and intent
