---
description: Enforce the use of enhanced logging system for structured, performant, and maintainable logging across all application layers. This rule covers server-side Logger/AsyncFileLoggerAdapter and client-side RemoteLoggerAdapter with React integration. IMPORTANT: This is a single-instance logging system designed for simplicity - we do not want to change it for now.
globs: src/**/*.{ts,tsx}
alwaysApply: true
---

Sub rule 1: Server-Side Logging System Usage
- Use `Logger` as the primary logging interface for server-side code
- Import from: `import { Logger } from '@/application/shared/Logger'`
- Obtain logger through dependency injection: `constructor(@inject('Logger') private logger: Logger)`
- Use `EnhancedLoggerServiceLocator.getLogger()` for manual instantiation when needed
- Never use `console.log`, `console.error`, `console.warn`, or `console.debug` in server-side code

Sub rule 2: Client-Side Logging System Usage
- Use `useLogger` hook for logging in React components
- Import from: `import { useLogger } from '@/presentation/shared/hooks/useLogger'`
- Call the hook in components: `const logger = useLogger()`
- Client logs automatically batch and send to server via RemoteLoggerAdapter to `/api/logs` endpoint
- Client logs are written to files using the same logging system as server-side logs
- Never use `console.log`, `console.error`, `console.warn`, or `console.debug` in client-side code
- RemoteLoggerAdapter handles batching, retries, and ensures unified file-based logging
- All client-side logs end up in the same log files as server-side logs

Sub rule 3: Log Level Usage
- Use `logger.debug()` for detailed troubleshooting information in development
- Use `logger.info()` for important business events and successful operations
- Use `logger.warn()` for concerning situations that don't stop the application
- Use `logger.error()` for error conditions that impact functionality
- Use `logger.execute(LogLevel.ERROR, message, metadata)` for dynamic level selection
- Apply same log levels consistently across server and client-side logging

Sub rule 4: Structured Logging with Metadata
- Always include relevant metadata in log entries for better debugging
- Use structured objects for metadata: `logger.info('User login', { userId, email, ip })`
- Include correlation IDs for request tracking: `logger.info('API call', { requestId, userId })`
- Add context information: `logger.error('Database error', { query, table, error })`
- Use consistent field names: `userId`, `requestId`, `operation`, `duration`, `success`
- Client-side logs automatically include browser context: `userAgent`, `url`, `timestamp`
- Server-side logs automatically include server context: `method`, `url`, `ip`, `userAgent`
- Both client and server logs are written to the same file-based logging system via `/api/logs` endpoint

Sub rule 5: Specialized Logging Methods
- Use `logger.logApiRequest(method, url, userId, metadata)` for API request logging (server-side)
- Use `logger.logApiResponse(method, url, statusCode, duration, metadata)` for API response logging (server-side)
- Use `logger.logError(error, message, metadata)` for proper error object handling (both sides)
- Use `logger.logSecurity(context)` for security events (both sides: login attempts, failures, etc.)
- Use `logger.logUserAction(action, userId, metadata)` for user behavior tracking (both sides)
- Use `logger.logBusinessEvent(event, metadata)` for important business milestones (both sides)
- Client-side specialized methods automatically route to server via RemoteLoggerAdapter
- All client-side specialized methods write to the same file-based logging system as server-side logs
- No console methods are used - all logging goes through unified file-based system

Sub rule 6: Performance Measurement
- Use `logger.startTimer(operation, metadata)` to begin performance measurement
- Use `logger.endTimer(metrics, additionalMetadata)` to complete and log timing
- Use `logger.measure(operation, asyncFn, metadata)` for automatic async operation timing
- Performance warnings automatically trigger for operations > 1000ms
- Include operation context: `logger.measure('database-query', () => fetchData(), { table, query })`
- Client-side performance measurement includes network latency to server for logging
- Server-side performance measurement includes database and processing times

Sub rule 7: Contextual Logging
- Use `logger.withContext(context)` to create contextual loggers with preset metadata (server-side)
- Include request context: `const contextualLogger = logger.withContext({ requestId, userId })`
- Use contextual loggers throughout request lifecycle for consistent correlation
- Chain context: `logger.withContext({ module: 'auth' }).withContext({ operation: 'login' })`
- Context automatically includes correlation IDs and request tracking
- Client-side context automatically includes browser session information
- Server-side context automatically includes request/response cycle information

Sub rule 8: Conditional and Batch Logging
- Use `logger.logIf(condition, level, message, metadata)` for conditional logging
- Use `logger.debugIf(message, condition, metadata)` for debug-only conditional logging
- Use `logger.batch(entries)` for multiple log entries to improve performance (server-side)
- Client-side batching is automatic via RemoteLoggerAdapter (5 seconds or 10 entries)
- Server-side batch example: `logger.batch([{ level: LogLevel.INFO, message: 'Started' }, { level: LogLevel.INFO, message: 'Completed' }])`
- Use conditional logging to avoid performance impact in production
- Client-side logs queue when offline and flush when connection restored

Sub rule 9: Error Handling and Logging
- Always log errors with proper error object handling: `logger.logError(error, 'Operation failed', { context })`
- Include stack traces automatically through `logError` method
- Use structured error information: `logger.error('Validation failed', { errors, field, value })`
- Log retry attempts: `logger.warn('Retrying operation', { attempt, maxAttempts, delay })`
- Include error context for debugging: `logger.error('Database connection failed', { host, port, database })`
- Client-side errors include browser context and automatically route to server
- Server-side errors include full request context and server environment
- RemoteLoggerAdapter handles network errors with exponential backoff retry

Sub rule 10: React Component Logging Integration
- Wrap components with `LoggerProvider` to enable logging throughout component tree
- Import provider: `import { LoggerProvider } from '@/presentation/shared/contexts/LoggerContext'`
- Use `useLogger` hook in functional components: `const logger = useLogger()`
- Provider automatically sets up RemoteLoggerAdapter for client-side logging
- Ensure `LoggerProvider` is at root of component tree or high enough for all logging components

Sub rule 11: Single-Instance System Limitation
- This logging system is designed for **single-instance deployments only**
- Rate limiting uses in-memory storage and resets on server restart
- Log files are stored locally on each server instance
- No shared state between multiple server instances
- Do not implement Redis, Database, or distributed rate limiting
- Do not add external logging service dependencies
- Keep the logging system simple and focused on single-instance use cases
- For multi-instance needs, use external centralized logging services instead

Sub rule 12: Testing and Logging
- Mock `Logger` in server-side tests using jest mocks or test doubles
- Mock `useLogger` hook in client-side component tests: `jest.mock('@/presentation/shared/hooks/useLogger')`
- Verify log calls in tests: `expect(mockLogger.logInfo).toHaveBeenCalledWith(expectedMessage, expectedMetadata)`
- Test logging behavior: `expect(() => logger.logError(error)).not.toThrow()`
- Use test-specific log levels to avoid noise in test output
- Avoid logging in test assertions; use test framework features instead
- For component tests, wrap with `LoggerProvider` or mock the `useLogger` hook

