---
description: Define the client-side logging architecture using RemoteLoggerAdapter and React integration, ensuring centralized logging through server endpoints with proper batching, retry logic, and fallback mechanisms.
globs: src/presentation/**/*.{ts,tsx}, src/infrastructure/shared/adapters/RemoteLoggerAdapter.ts
alwaysApply: true
---

Sub rule 1: Client-Side Logger Architecture
- Use `RemoteLoggerAdapter` as the sole client-side logging implementation
- Import from: `import { RemoteLoggerAdapter } from '@/infrastructure/shared/adapters/RemoteLoggerAdapter'`
- RemoteLoggerAdapter implements singleton pattern for consistent logging across application
- All client logs automatically route to server `/api/logs` endpoint
- Never use direct file system access or Node.js-specific logging on client-side

Sub rule 2: React Integration Pattern
- Use `LoggerProvider` context to provide logger throughout component tree
- Import from: `import { LoggerProvider } from '@/presentation/shared/contexts/LoggerContext'`
- Use `useLogger` hook for accessing logger in components: `import { useLogger } from '@/presentation/shared/hooks/useLogger'`
- Provider must wrap components that need logging at appropriate level in component tree
- Never use dependency injection containers for client-side logging

Sub rule 3: Batching and Performance
- RemoteLoggerAdapter automatically batches logs (5 seconds or 10 entries threshold)
- Batching reduces network overhead and improves performance
- Logs flush immediately on error level messages for critical issues
- Automatic batching includes retry logic with exponential backoff (1s, 2s, 4s, 8s, 16s)
- Maximum 5 retry attempts before falling back to console logging

Sub rule 4: Fallback and Error Handling
- RemoteLoggerAdapter falls back to console logging when server unavailable
- Offline support: logs queue when offline, flush when connection restored
- Network errors handled gracefully with user notification only for critical failures
- Fallback ensures no log entries are lost during server outages
- Console fallback maintains same log levels and formatting as server logs

Sub rule 5: Automatic Context Enrichment
- Client logs automatically include browser context: `userAgent`, `url`, `timestamp`, `source: 'client'`
- Session information automatically added when available: `sessionId`, `userId`
- Device context included: `screenWidth`, `screenHeight`, `language`, `timezone`
- Performance context added: `memoryUsage`, `connectionType` (when available)
- Automatic context reduces need for manual metadata in most cases

Sub rule 6: Provider Setup Requirements
- `LoggerProvider` must be initialized at application root or high-level layout
- Provider automatically creates and configures RemoteLoggerAdapter instance
- Provider handles logger cleanup and resource management
- Multiple provider instances automatically use same singleton RemoteLoggerAdapter
- Provider can be configured with custom options if needed

Sub rule 7: Component Usage Patterns
- Call `useLogger` hook at component top level: `const logger = useLogger()`
- Use logger throughout component lifecycle: `logger.info('Component mounted', { componentName })`
- Log user interactions: `logger.logUserAction('button-click', userId, { button: 'submit' })`
- Log errors with context: `logger.logError(error, 'Form submission failed', { form, field })`
- Performance measurement: `logger.measure('component-render', () => renderComponent(), { componentName })`

Sub rule 8: Server Communication
- Client logs sent to `/api/logs` endpoint with proper authentication headers
- Request format matches server expectations: `[{ level, message, metadata, timestamp, source }]`
- Automatic retry with exponential backoff for failed requests
- Rate limiting respected (100 requests/minute per IP)
- Request batching reduces server load and network calls

Sub rule 9: Testing Client-Side Logging
- Mock `useLogger` hook in component tests: `jest.mock('@/presentation/shared/hooks/useLogger')`
- Test logging behavior without actual network calls
- Verify log calls in tests: `expect(mockLogger.logInfo).toHaveBeenCalledWith(message, metadata)`
- Test fallback behavior by simulating network failures
- Use test-specific logger instances to avoid polluting production logs

Sub rule 10: Migration from Legacy Patterns
- Remove dependency injection containers for client-side code
- Replace `clientContainer.ts` patterns with React context/hook patterns
- Migrate existing console.log calls to useLogger hook
- Update component tests to mock useLogger instead of DI containers
- Ensure all client-side logging goes through centralized RemoteLoggerAdapter

Examples:

Basic component logging:
```typescript
// Good
import { useLogger } from '@/presentation/shared/hooks/useLogger';

function UserProfile({ userId }: { userId: string }) {
  const logger = useLogger();
  const [profile, setProfile] = useState(null);

  useEffect(() => {
    logger.info('Loading user profile', { userId });
    
    fetchUserProfile(userId)
      .then(data => {
        setProfile(data);
        logger.info('Profile loaded successfully', { userId, hasData: !!data });
      })
      .catch(error => {
        logger.logError(error, 'Failed to load profile', { userId });
      });
  }, [userId, logger]);

  return <div>{/* profile JSX */}</div>;
}
```

Provider setup:
```typescript
// Good - Root layout or app component
import { LoggerProvider } from '@/presentation/shared/contexts/LoggerContext';

export default function App({ Component, pageProps }: AppProps) {
  return (
    <LoggerProvider>
      <Component {...pageProps} />
    </LoggerProvider>
  );
}
```

User interaction logging:
```typescript
// Good
function SubmitButton({ onSubmit }: { onSubmit: () => Promise<void> }) {
  const logger = useLogger();

  const handleClick = async () => {
    logger.logUserAction('submit-button-clicked', undefined, { 
      component: 'SubmitButton',
      timestamp: Date.now()
    });

    try {
      await onSubmit();
      logger.info('Form submitted successfully');
    } catch (error) {
      logger.logError(error, 'Form submission failed');
    }
  };

  return <button onClick={handleClick}>Submit</button>;
}
```

Performance measurement:
```typescript
// Good
function DataProcessor({ data }: { data: any[] }) {
  const logger = useLogger();

  const processData = async () => {
    const result = await logger.measure('data-processing', async () => {
      return data.map(item => ({
        ...item,
        processed: true,
        processedAt: Date.now()
      }));
    }, { itemCount: data.length });

    logger.info('Data processing completed', { 
      inputCount: data.length, 
      outputCount: result.length 
    });

    return result;
  };

  return <button onClick={processData}>Process Data</button>;
}
```

Testing with mocked logger:
```typescript
// Good
import { render, screen, fireEvent } from '@testing-library/react';
import { useLogger } from '@/presentation/shared/hooks/useLogger';

jest.mock('@/presentation/shared/hooks/useLogger');
const mockLogger = {
  info: jest.fn(),
  logError: jest.fn(),
  logUserAction: jest.fn(),
  measure: jest.fn()
};

(useLogger as jest.Mock).mockReturnValue(mockLogger);

describe('UserProfile', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('logs profile loading', async () => {
    render(<UserProfile userId="123" />);
    
    expect(mockLogger.info).toHaveBeenCalledWith(
      'Loading user profile', 
      { userId: '123' }
    );
  });
});
```