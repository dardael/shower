---
description: Enforce clean code principles across the codebase to ensure maintainability, readability, and quality. This rule covers general clean code practices with specific guidance for TypeScript and Next.js projects.
globs: src/**/*.{ts,tsx,js,jsx}
alwaysApply: true
---

Sub rule 1: Meaningful Names
- Use descriptive and pronounceable names for variables, functions, and classes
- Avoid abbreviations and single-letter variables except for loop counters
- Use verbs for function names (e.g., `getUserData`, `calculateTotal`)
- Use nouns for class names (e.g., `UserService`, `DatabaseConnection`)
- Name interfaces descriptively with `I` prefix: `IUserService`, `IRepository`

Sub rule 2: Small and Focused Functions
- Keep functions under 20 lines when possible
- Functions should do one thing and do it well
- Avoid functions with more than 3 parameters; use objects for multiple parameters
- Use pure functions when possible (no side effects)
- Return early from functions to reduce nesting

Sub rule 3: Code Organization and Structure
- Group related code together
- Keep files focused on a single responsibility
- Use barrel exports (`index.ts`) for clean imports
- Organize imports: external libraries first, then internal modules
- Avoid deep nesting (more than 3 levels)

Sub rule 4: Error Handling
- Handle errors at the appropriate level
- Use specific error types with descriptive messages
- Avoid catching exceptions without proper handling
- Use Result/Either patterns for better error handling
- Log errors with sufficient context

Sub rule 5: Logging Practices
- Never use `console.log`, `console.error`, `console.warn`, or `console.debug` in production code
- Use the enhanced logging system with proper architecture separation:
  - Server-side: `Logger` class with dependency injection
  - Client-side: `useLogger` hook with React context
- Server-side import: `import { Logger } from '@/application/shared/Logger'`
- Server-side usage: `constructor(@inject('Logger') private logger: Logger)`
- Client-side import: `import { useLogger } from '@/presentation/shared/hooks/useLogger'`
- Client-side usage: `const logger = useLogger()`
- Use appropriate methods: `logger.debug()`, `logger.info()`, `logger.warn()`, `logger.error()`
- Include structured metadata in all log entries for better debugging and monitoring
- Use specialized methods: `logger.logApiRequest()`, `logger.logError()`, `logger.logSecurity()`, `logger.measure()`
- For detailed logging guidelines and examples, see the enhanced-logging-system and client-side-logging-architecture rules

Sub rule 6: TypeScript Specific Clean Code
- Use interfaces over types for object shapes that can be extended
- Prefer explicit return types over inferred types
- Use utility types (`Pick`, `Omit`, `Partial`) effectively
- Avoid using `any`; use `unknown` for truly unknown data
- Use generics for reusable and type-safe code

Sub rule 7: Next.js Specific Clean Code
- Keep pages/route handlers thin and focused
- Move business logic to service layers
- Use server components by default, client components only when necessary
- Separate data fetching from presentation logic
- Use proper error boundaries for React components

Sub rule 8: Comments and Documentation
- Write self-documenting code that needs minimal comments
- Use comments only to explain why, not what
- Update comments when code changes
- Avoid commented-out code; remove it instead
- Use JSDoc for complex functions with clear parameter and return descriptions

Sub rule 9: Code Duplication (DRY)
- Extract common logic into reusable functions
- Use composition over inheritance
- Create utility functions for repeated operations
- Avoid copy-pasting code; refactor instead
- Use constants for repeated values

Sub rule 10: Readability and Formatting
- Follow consistent formatting (use Prettier)
- Use meaningful whitespace to improve readability
- Keep lines under 80 characters when possible
- Use descriptive variable names even in short scopes
- Write code as if the next developer is a violent psychopath

Sub rule 11: Testing and Clean Code
- Write tests that are easy to understand
- Use descriptive test names that explain the behavior
- Keep tests simple and focused
- Test behavior, not implementation details
- Use fixtures and helpers to reduce test duplication